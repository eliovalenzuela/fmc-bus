\input texinfo    @c -*-texinfo-*-
%
% fmc-bus.in - main file for the documentation
%
%%%%

%------------------------------------------------------------------------------
%
%                         NOTE FOR THE UNAWARE USER
%                         =========================
%
%    This file is a texinfo source. It isn't the binary file of some strange
%    editor of mine. If you want ASCII, you should "make fmc-bus.txt".
%
%------------------------------------------------------------------------------

%
% This is not a conventional info file...
% I use three extra features:
%   - The '%' as a comment marker, if at beginning of line ("\%" -> "%")
%   - leading blanks are allowed (this is something I can't live without)
%   - braces are automatically escaped when they appear in example blocks
%

@comment %**start of header
@documentlanguage en
@setfilename fmc-bus.info
@settitle fmc-bus
@iftex
@afourpaper
@end iftex
@paragraphindent none
@comment %**end of header

@setchapternewpage off

@set update-month October 2012

@finalout

@titlepage
@title FMC Bus Abstraction for Linux
@subtitle @value{update-month}
@subtitle A kernel bus to support FMC mezzanines and carriers
@author Alessandro Rubini for CERN (BE-CO-HT)
@end titlepage
@headings single

@c ##########################################################################
@iftex
@contents
@end iftex

@c ##########################################################################
@node Top
@top Introduction

This document describes the implementation of the @i{fmc} bus for
Linux.  FMC (FPGA Mezzanine Carrier) is the standard we use for our
I/O devices, in the context of White Rabbit and related hardware.

In our I/O environments we need to write drivers for each mezzanine
card, and such drivers must work independent of the carrier being used.
To achieve this, we abstract the FMC interface.

We have a carrier for PCI-E called @i{SPEC} and one for VME called
@i{SVEC}, but more are planned.  Also, we support stand-alone devices
(usually plugged on a SPEC card), controlled through Etherbone,
developed by GSI.

Code and documentation for the FMC bus was born as part of the
@i{spec-sw} project, but now it lives in its own project. Other
projects, i.e. software support for the various carriers, should
include this as a submodule.

The most up to date version of code and documentation is always
available from the repository you can clone from:

@example
   git://ohwr.org/fmc-projects/fmc-bus.git (read-only)
   git@@ohwr.org:fmc-projects/fmc-bus.git (read-write for developers)
@end example

Selected versions of the documentation, as well as complete tar
archives for selected revisions are placed to the @i{Files} section of
the project: @url{http://www.ohwr.org/projects/fmc-bus/files}

@menu
* What is a Linux Bus::         
* FMC Device::                  
* FMC Driver::                  
* The API Offered by Carriers::  
@end menu

@c ##########################################################################
@node What is a Linux Bus
@chapter What is a Linux Bus

Within the Linux kernel, a @i{bus} is a data structure with a few
methods.  It's main role is registering a list of devices and a list
of drivers, offering a @i{match} function that compares the respective
identifiers (in a bus-specific way) to assign drivers to devices.

Activation and deactivation of devices happens through the @i{probe}
and @i{remove} functions of the respective driver; an advanced user
can also use @i{sysfs} to change the binding of drivers to devices
(for example, if more than one driver can drive the same device you
may want to force the choice).

@c ##########################################################################
@node Functions Exported by fmc.ko
@chapter Functions Exported by fmc.ko

The FMC core exports the usual 4 functions that are needed for a bus
to work:

@smallexample
   int fmc_driver_register(struct fmc_driver *drv);
   void fmc_driver_unregister(struct fmc_driver *drv);
   int fmc_device_register(struct fmc_device *tdev);
   void fmc_device_unregister(struct fmc_device *tdev);

   uint32_t fmc_readl(struct fmc_device *fmc, int offset);
   void fmc_writel(struct fmc_device *fmc, uint32_t val, int off);
   void *fmc_get_drvdata(struct fmc_device *fmc);
   void fmc_set_drvdata(struct fmc_device *fmc, void *data);
@end smallexample

They should be self-explicative, so nothing is added here. The data
structure that describe a device is detailed in @ref{FMC Device},
the one that describes a driver is detailed in @ref{FMC Driver}.

@c ##########################################################################
@node FMC Device
@chapter FMC Device

Within the Linux bus framework, the FMC device is created and registered by the
carrier driver. For example, the PCI driver for the SPEC card fills a
data structure for each SPEC that it drives, and registers an
associated FMC device.  The SVEC driver can do exactly the same for
the VME carrier (actually, it should do it twice, because the SVEC
carries two FMC mezzanines).  Similarly, an Etherbone driver will be
able to register its own FMC devices, offering communication primitives
through frame exchange.

The contents of the EEPROM within the FMC will be used for
identification purposes, i.e. for matching the device with its own
driver. For this reason the device structure includes a complete copy
of the EEPROM (actually, the carrier driver may choose to only return
the leading part of it).

The following listing shows
the current structure defining a device. Please note that all
the machinery is in place but some details may still change in the future.
For this reason, there is a version field at the beginning of the structure.
As usual, the minor number will change for compatible changes (like a new
flag) and the major number will increase when an incompatible change
happens (for example, a change in layout of some @i{fmc} data structures).
Device writers should just set it to the
value @t{FMC_VERSION}, and be ready to get back @t{-EINVAL} at
registration time.

@smallexample
struct fmc_device {
        unsigned long version;          /* to be set to FMC_VERSION */
        struct fmc_device_id id;        /* for the match function */
        struct fmc_operations *op;      /* carrier-provided */
        int irq;                        /* according to host bus. 0 == none */
        int eeprom_len;                 /* Usually 8kB, may be less */
        uint8_t *eeprom;                /* Full contents or leading part */
        char *carrier_name;             /* "SPEC" or similar, for special use */
        void *carrier_data;             /* "struct spec *" or equivalent */
        __iomem void *base;             /* May be NULL (Etherbone) */
        struct device dev;              /* For Linux use */
        struct device *hwdev;           /* The underlying hardware device */
        struct sdb_array *sdb;
        void *mezzanine_data;
};
@end smallexample

The meaning of each field is summarized in its own line above. All
of the fields must be filled by the carrier driver before registration,
with a few exceptions; please note that @i{hwdev} is used for messages, using
@code{dev_err()} or similar functions, so it must be properly set
or the system will @i{Oops} with a NULL pointer pretty soon.
Similarly, the carrier must read its own EEPROM memory before registering
the driver.

The fields that are not set by the carrier are: @i{fmc_device_id},
which is set by the bus controller according to EEPROM contents; @i{sdb},
which is set by the bus controller when scanning an SDB bus; @i{mezzanine_data}
which is a pointer used by the mezzanine driver

@b{Note}: @i{mezzanine_data} may be redundant, because Linux offers
the @i{drvdata} approach, to the field may be removed in later
versions of this bus implementation.

As I write this, she SPEC carrier is already completely functional in
the @i{fmc-bus} environment, and is a good reference to look at.

@c ==========================================================================
@node The API Offered by Carriers
@section The API Offered by Carriers

The carrier provides a number of methods by means of the
@code{fmc_operations} structure, which currently is defined like this
(again, it is a moving target, please refer to the header rather than
this document):

@smallexample
struct fmc_operations {
        uint32_t (*readl)(struct fmc_device *fmc, int offset);
        void (*writel)(struct fmc_device *fmc, uint32_t value, int offset);
        int (*reprogram)(struct fmc_device *f, struct fmc_driver *d, char *gw);
        int (*validate)(struct fmc_device *fmc, struct fmc_driver *drv);
        int (*irq_request)(struct fmc_device *fmc, irq_handler_t h,
                           char *name, int flags);
        void (*irq_ack)(struct fmc_device *fmc);
        int (*irq_free)(struct fmc_device *fmc);
        int (*gpio_config)(struct fmc_device *fmc, struct fmc_gpio *gpio,
                           int ngpio);
        int (*read_ee)(struct fmc_device *fmc, int pos, void *d, int l);
        int (*write_ee)(struct fmc_device *fmc, int pos, const void *d, int l);
};
@end smallexample

The individual methods perform the following tasks:

@table @code
@item readl
@itemx writel

	These functions access FPGA registers by whatever means the
        carrier offers. They are not expected to fail, and most of the time
        they will just make a memory access to the host bus. If the
        carrier provides a @i{base} pointer, the driver may use direct
        access through that pointer. For this reason the header offers
        the inline functions @i{fmc_readl} and @i{fmc_writel} that
        access @i{base} if the respective method is NULL. A driver that
        wants to be portable and efficient should use @i{fmc_readl}
        and @i{fmc_writel}.
        For Etherbone, or other non-local carriers,
        error-management is still to be defined.

@item validate

	Module parameters are used to manage different applications for
        two or more boards of the same kind. Validation is based on the
        @i{busid} module parameter, if provided, and returns the   
        matching index in the associated array. See @ref{Module Parameters}
        in in doubt. If no match is found, @code{-ENOENT}
        is returned; if the user didn't pass @code{busid=}, all
        devices will pass validation.  The value returned
        by the validate method can be used as index into other parameters
        (for example, some drivers use the @code{lm32=} parameter in this
        way). Such ``generic parameters'' are documented in
        @ref{Module Parameters}, below. The @i{validate} method is used
        by @code{fmc-trivial.ko}, described in @ref{fmc-trivial}.

@item reprogram

	The carrier enumerates FMC devices by loading a standard (or
        @i{golden}) FPGA binary that allows EEPROM access. Each driver, then,
        will need to reprogram the FPGA by calling this
        function.  If the name argument is NULL,
        the carrier should reprogram the golden binary. If the gateware name
        has been overridden through module parameters (in a carrier-specific
        way) the file loaded will match the parameters. Per-device gateware
        names can be specified using the @code{gateware=} parameter, see
        @ref{Module Parameters}.

@item irq_request
@itemx irq_ack
@itemx irq_free

	Interrupt management is carrier-specific, so it is abstracted
        as operations. The interrupt number is listed in the device
        structure, and for the mezzanine driver the number is only informative.
        The handler will receive the @i{fmc} pointer as @i{dev_id}; the
        @i{flags} argument is passed to the Linux @i{request_irq} function,
        but fmc-specific flags may be added in the future. You'll most
        likely want to pass the @code{IRQF_SHARED} flag.

@item gpio_config

	The method allows to configure a GPIO pin in the carrier, and
        read its current value if it is configured as input. See
        @ref{The GPIO Abstraction} for details.
        
@item read_ee
@itemx write_ee

	Read or write the EEPROM. The functions are expected to be only
        called before reprogramming and the carrier should refuse them
        with @code{ENODEV} after reprogramming.  The offset is 
        expected to be within 8kB (the current size),
        but addresses up to 1MB are reserved to fit bigger I2C
        devices in the future. Carriers may offer
        access to other internal flash memories using these same methods:
        for example the SPEC driver may define that its carrier I2C memory
        is seen at offset 1M and the internal SPI flash is seen at offset
        16M.  This multiplexing of several flash memories in the same
        address space is is carrier-specific and should only be used by
        a driver that has verified the @code{carrier_name} field.

@end table

@c ==========================================================================
@node The GPIO Abstraction
@section The GPIO Abstraction

Support for GPIO pins in the @i{fmc-bus} environment is not very
straightforward and deserves special discussion.

While the general idea of a carrier-independent driver seems to fly,
configuration of specific signals within the carrier needs at least
some knowledge of the carrier itself.  For this reason, the specific
driver can request to configure carrier-specific GPIO pins, numbered
from 0 to at most 4095.  Configuration is performed by passing
a pointer to an array of @t{struct fmc_gpio} items, as well as
the length of the array. This is the data structure:

@example
   struct fmc_gpio {
           char *carrier_name;
           int gpio;
           int _gpio;      /* internal use by the carrier */
           int mode;       /* GPIOF_DIR_OUT etc, from <linux/gpio.h> */
           int irqmode;    /* IRQF_TRIGGER_LOW and so on */
   };
@end example

By specifying a @i{carrier_name} for each pin, the driver may access
different pins in different carriers.  The @i{gpio_config} method
is expected to return
the number of pins successfully configured, ignoring requests for other
carriers. However, if no pin is configured (because no structure at all
refers to the current @i{carrier_name}), the operation returns an error
so the caller will know that it is running under a yet-unsupported carrier.

So, for example, a driver
that has been developed and tested on both the SPEC and the SVEC may
request configuration of two different GPIO pins, and expect one such
configuration to succeed -- if none succeeds it most likely means that
the current carrier is a still-unknown one.

If, however, your GPIO pin has a specific known role, you can
pass a special number in the @t{gpio} field, using one of the
following macros:

@example
   #define FMC_GPIO_RAW(x)         (x)             /* 4096 of them */
   #define FMC_GPIO_IRQ(x)         ((x) + 0x1000)  /*  256 of them */
   #define FMC_GPIO_LED(x)         ((x) + 0x1100)  /*  256 of them */
   #define FMC_GPIO_KEY(x)         ((x) + 0x1200)  /*  256 of them */
   #define FMC_GPIO_TP(x)          ((x) + 0x1300)  /*  256 of them */
   #define FMC_GPIO_USER(x)        ((x) + 0x1400)  /*  256 of them */
@end example

Use of virtual GPIO numbers (anything but @t{FMC_GPIO_RAW}) is allowed
provided the @i{carrier_name} field in the data structure
is left unspecified (NULL). Each
carrier is responsible for providing a mapping between virtual and
physical GPIO numbers. The carrier may then use the @t{_gpio} field
to cache the result of this mapping.

All carriers must map their I/O lines
to the sets above starting from zero.  The SPEC, for example, maps
interrupt pins 0 and 1, and test points 0 through 3 (even if the test
points on the PCB are called 5,6,7,8).

If, for example, a driver requires a free LED and a test point (for a
scope probe to be plugged at some point during development) it may ask
for @t{FMC_GPIO_LED(0)} and @t{FMC_GPIO_TP(0)}. Each carrier will
provide suitable GPIO pins.  Clearly, the person running the drivers
will know the order used by the specific carrier driver in assigning
leds and testpoints, so to make a carrier-dependent use of the diagnostic tools.

In theory, some form of autodetection should be possible: a driver
like the @i{wr-nic} (which uses IRQ(1) on the SPEC card) should
configure IRQ(0), make a test with software-generated interrupts and
configure IRQ(1) if the test fails. This probing step should be used
because even if the @i{wr-nic} gateware is
known to use IRQ1 on the SPEC, the driver should be
carrier-independent and thus use IRQ(0) as a first bet -- actually,
the knowledge that IRQ0 may fail is carrier-dependent information, but
using it doesn't make the driver unsuitable for other carriers.

The return value of @i{gpio_config} is defined as follows:

@itemize @bullet
@item If no pin in the array can be used by the carrier, @code{-ENODEV}.
@item If at least one virtual GPIO number cannot be mapped, @code{-ENOENT}.
@item On success, 0 or positive. The value returned is the number
of high input bits (if no input is configured, the value for success is 0).
@end itemize

While I admit the procedure is not completely straightforward, it
allows configuration, input and output with a single carrier
operation.  Given the typical use case of FMC devices, GPIO operations
are not expected to ever by in hot paths, and GPIO access so fare has
only been used to configure the interrupt pin, mode and
polarity. Especially reading inputs is not expected to be common. If
your device has GPIO capabilities in the hot path, you should consider
using the kernel's GPIO mechanisms.

@c ##########################################################################
@node FMC Driver
@chapter FMC Driver

An FMC driver is concerned with the specific mezzanine and associated
gateware. As such, it is expected to be independent of
the carrier being used.  The matching between device and driver is
only based on the content of the EEPROM (as mandated by the FMC
standard) and the driver will perform I/O accesses only by means of
carrier-provided functions.

In some special cases it is possible for a driver to directly access
FPGA registers, by means of the @code{base} field of the device
structure. This may be needed for high-bandwidth peripherals like fast ADC
cards. If the @i{device} module registered a remote device (for example
by means of Etherbone), the @code{base} pointer will be NULL.
Therefore, drivers must be ready to deal with NULL base pointers, and
fail gracefully.  Most driver, however, are not expected to access
the pointer directly but run @i{fmc_readl} and @i{fmc_writel} instead,
which will work in any case.

In even more special cases, the driver may access carrier-specific
functionality: the @code{carrier_name} string allows the driver to
check which is the current carrier and make use of the
@code{carrier_data} pointer.  We chose to use carrier names rather
than numeric identifiers for greater flexibility, but also to avoid a
central registry within the @code{fmc.h} file -- we hope other users
will exploit our framework with their own carriers.  An example use of
carrier names is in GPIO setup (see @ref{The GPIO Abstraction}),
although the name match is not expected to be performed by the driver.
If you depend on specific carriers, please check the carrier name and
fail gracefully if your driver finds it is running in an unknown
environment.

@c ==========================================================================
@node Module Parameters
@section Module Parameters

Most of the FMC drivers need the same
set of kernel parameters. This package includes support
to implement common parameters by means of fields
in the @code{fmc_driver} structure and simple macro definitions.

The parameters are carrier-specific, in that they rely on the @i{busid}
concept, that varies among carriers. For the SPEC, the identifier
is a PCI bus and @i{devfn} number, 16 bits wide in total;
drivers for other carriers will most likely offer something similar
but not identical, and some code duplication is unavoidable.

This is the list of parameters that are common to several modules
to see how they are actually used, please look at @i{spec-trivial.c}.

@table @code

@item busid=

	This is an array of integers, listing carrier-specific
        identification numbers. For PIC, for example,
        @code{0x0400} represents bus 4, slot 0.
        If any such ID is specified, the driver will only
        accept to drive cards that appear in the list (even if the
        FMC ID matches). This is accomplished by the @i{validate}
        carrier method.

@item gateware=

	The argument is an array of strings. If no @i{busid=} is
        specified, the first string of @i{gateware=} is used for
        all cards; otherwise the identifiers and gateware names are
        paired one by one, in the order specified.

@item show_sdb=

	For modules supporting it, this parameter asks to
        show the SDB internal structure by means of kernel messages. It is
        disabled by default because those lines tend to hide more
        important messages, if you look at the system console while
        loading the drivers.

@end table

For example, if you are using the trivial driver to load two different
gateware files to two different cards, you can use the following
parameters to load different binaries to the cards, after looking up
the PCI identifiers. This has been tested with a SPEC carrier.

@smallexample
   insmod fmc-trivial.ko \
                         busid=0x0200,0x0400 \
                         gateware=fmc/fine-delay.bin,fmc/simple-dio.bin
@end smallexample

Please note that not all sub-modules support all of those parameters.
You can use @i{modinfo} to check what is supported by each module.

@c ==========================================================================
@node fmc-trivial
@section fmc-trivial

The simple module @i{fmc-trivial} is just a simple client that
registers an interrupt handler. I used it to verify the basic mechanism
of the FMC bus and how interrupts worked.

The module implements the generic FMC parameters, so it can program a
different gateware file in each card. The whole list of parameters it
accepts are:

@table @code

@item busid=
@itemx gateware=
      Generic parameters. See @ref{Module Parameters}.

@c no docbook is generated, so the following is like "#if 0"
@ifdocbook
@item sdb=

	This is an array of integers, specifying the @i{sdb}
        starting address after programming the gateware. See
        @ref{Module Parameters} about how this is used in multi-board
        environments.
       
@item lm32=

	This is a array of strings like @code{gateware=},
        listing the name or names
        to be used to reprogram the internal LM32. The same rules as for
        @code{gateware=} above are used for matching binaries and cards.
        The carrier will copy the @i{lm32} executable to the first
        SDB record that is mapped as ``@code{WB4-BlockRAM}'' (thus,
        it needs the @code{sdb=} values to be specified.
@end ifdocbook
@end table

This driver is worth reading, but it is not worth describing here.

@c ==========================================================================
@node fmc-write-eeprom
@section fmc-write-eeprom

This module is designed to load a binary file from @i{/lib/firmware}
and to write it to the internal EEPROM of the mezzanine card. This
driver uses the @code{busid} generic parameter.

Overwriting the EEPROM is not something you should do daily, and it is
expected to only happen during manufacturing. For this reason, the
module makes it unlikely for the random user to change a working EEPROM.

The module takes the following measures:

@itemize @bullet

@item It accepts a @code{file=} argument (within @i{/lib/firmware})
and if no such argument is received, it doesn't write anything to EEPROM
(i.e. there is no default file name).

@item If the file name ends with @code{.bin} it is written verbatim
starting at offset 0.

@item If the file name ends with @code{.tlv} it is interpreted as
type-length-value (i.e., it allows @i{writev(2)}-like operation).

@item If the file name doesn't match any of the patterns above, it is
ignored and no write is performed.

@item Only cards listed with @code{busid=} are written to. If no
@i{busid} is specified, no programming is done (and the probe function
of the driver will fail).

@end itemize

Each TLV tuple is formatted in this way: the header is 5 bytes,
followed by data. The first byte is @code{w} for @i{write}, the
next two bytes represent the address, in little-endian byte order, and
the next two represent the data length, in little-endian order. The length does
not include the header (it is the actual number of bytes to be
written).

This is a real example: that writes 5 bytes at position 0x110:

@smallexample
   spusa.root# od -t x1 -Ax /lib/firmware/try.tlv
   000000 77 10 01 05 00 30 31 32 33 34
   00000a
   spusa.root# insmod /tmp/fmc-write-eeprom.ko busid=0x0200 file=try.tlv
   [19983.391498] spec 0000:03:00.0: write 5 bytes at 0x0110
   [19983.414615] spec 0000:03:00.0: write_eeprom: success
@end smallexample

Please note that you'll most likely want to use SDBFS to build your
EEPROM image, at least if your mezzanines are being used in the White Rabbit
environment. For this reason the TLV format is not expected to be used much
and is not expected to be developed further.

@c ##########################################################################
@node Writing your FMC Driver
@chapter Writing your FMC Driver

This chapter includes some suggestions about to write your own drivers
for FMC carriers or mezzanines.  It is the outcome of the experience I
gathered working with @i{fine-delay} and @code{wr-nic.ko} (currently
part of @i{spec-sw}, as I write this).

Driver writing is a known problem, which @i{only} requires you to know
your hardware and your frameworks. However, the choice to split the
overall FMC software design into several projects, and thus several
repositories, opens a new set of problems, related to how the projects
relate one another.

A typical carrier driver will be built against a specific version
of this @i{fmc-bus} package. A mezzanine driver, in addition, will
most often be developed under a specific carrier and will most likely
depend on features of the the specific carrier, at least initially.

To make the problem worse, a single host in your operating environment
(``in production'') may need tp run several FMC devices (thus several
FMC drivers), that expect to be using different versions of the
base packages -- according to when and where they have been written.

@c ==========================================================================
@node Versions of the Bus Abstraction
@section Versions of the Bus Abstraction

This @i{fmc-bus} package includes a @i{version} field at the beginning
of the two data structures, @code{fmc_device} and @code{fmc_driver}.

This version number is there to prevent mismatches between the
information passed by the FMC modules and how it is used by the core
code.  The version is not expected to change often, because the code
base is already pretty stable, and we don't expect to face many new
problems.

In general, if you experience a mismatch, you should just recompile
your carrier or mezzanine driver with the same version of @i{fmc-bus}
that you are running as a kernel module. If one of the structures has
a new field in there, the default of @i{all-bits-as-zero} will just
work. If your running @code{fmc.ko} is older than what the driver
wants to use, you may need to upgrade the core module, as the driver
wants to use data fields that are unknown to the core.  We foresee to
never introduce backward incompatibilities, so that step should be
safe as well.

If your working place uses several drivers based on @i{fmc-bus} and
you feature non-trivial dependencies, the safest best is using the
most recent @i{fmc-bus} release you can find, and recompile all the
rest against that version.  Again, please remember that version
changes are not frequent events.

@sp 1

To help clarifying how the versions is used, here is an example.

Pretty often, the mezzanine drivers need to register a new device of
some kind: a network card, an input device, or something else.
Several mezzanines may be installed in the same host computer, and we
need a way to tell which is which: using sequential numbering is not
reliable. The problem for diagnostics is already solved by the
@i{hwdev} field in the device structure: mezzanine drivers use
@code{dev_err(fmc->hwdev)} so the message includes proper identifiers
(e.g. the bus and slot numbers for PCI cards).

When we moved the @i{fine-delay} driver from being a SPEC-only driver
to a mezzanine @i{fmc-bus} driver, we found we needed an identifier to
register our top-level device (here, a ZIO driver).  The right
solution to this problems is for carrier drivers to already spell out
an identifier in the @code{fmc_device} structure, so mezzanine drivers
can use it.  This requires a version change.

@b{Note:} this change is not currently active, we are waiting to find
other issues and cluster all required changes in a single version
bump.

Drivers designed to work with an older versions of @i{fmc-bus} can
just be recompiled: they won't exploit the new feature but they will
work nonetheless. In this case, an old carrier driver will unknowingly
register 0 as its identifier (and mezzanine drivers use ``0'' to
trigger sequential enumeration).  An old mezzanine driver will not use
the carrier-provided identifier and will use whatever
technique it used under the older @i{fmc-bus} version.

While writing the @i{fine-delay} driver, we chose to use some special
SPEC-dependent code to extract the identifier, until the core offered
the new field. Carrier-specific code is explained in @ref{Suggestions
for Mezzanine Drivers}.

@c ==========================================================================
@node Git Submodule Crash Course
@section Git Submodule Crash Course

The mechanism we suggest to manage dependencies is @i{git submodule}.
It is already in place in the existing FMC drivers, but using it
requires some knowledge.  This is some basic information about
submodules, assuming you are already accustomed to simple @i{git}
repositories. (Tutorials exists, but they are usually too detailed
as a quick start).

If you are just a user of @i{fmc-bus}, not developing drivers, you
can jump to the next section.

@unnumberedsubsec Quick Summary

To make a long story short: a git repository can know that it uses a
checkout of another git repository, at a specific version.  The
@i{submodule} is checked out using a commit identifier, so it must be
considered read-only by the @i{supermodule} (the top-level project).

If you checked out a specific branch of the submodule, the supermodule
will record the specific commit at the time of the checkout, not the
branch it was using: branches are not followed automatically nor even
recorded in the supermodule.

@unnumberedsubsec Supermodules and Submodules

Then, here's the longer story. When you @i{clone} the supermodule, the
submodules won't be automatically cloned (unless you use @code{git
clone --recursive}, that nobody does by default and is not generally
good for @i{fmc-bus} drivers).  To check out the submodules you need
to @code{git submodule init; git submodule update} or equivalent).

Whenever you modify the content of a checked-out submodule, it is
reported by @code{git status}, that considers the directory where the
submodule lives as a single file.  Your established use of @code{git
status} will thus continue to work.  The messages you may get (if you
changed the submodule) are either @code{modified content} or
@code{untracked content}, like this (in the @i{fine-delay} mezzanine
driver):

@example
   morgana$ echo > fmc-bus/new-file
   morgana$ echo >> spec-sw//Makefile
   morgana$ git status
   [...]
   #       modified:   fmc-bus (untracked content)
   #       modified:   spec-sw (modified content)
@end example

If you wonder where does git store the checkout information
for the submodule, it lives in the "tree object" (i.e. directory)
where the submodule is checked-out.

@example
   morgana$ git ls-tree  HEAD | grep commit
   160000 commit dc30ce998628084c4402291e6052c7feb77be424  fmc-bus
   160000 commit 35480a19bc562ebfa76f4663d41d026ff1b9df29  spec-sw
@end example

If you want a different commit in the submodule (for example, you
fixed a bug in it), this is tracked by a commit in the supermodule,
because the hosting @i{tree} must be modified to record the new
submodule commit. It is correct, in general, to have a commit in the
supermodule that just updates the commit identifier of the submodule.
Sometimes, however, you commit the new submodule's version together
with changes in the supermodule that use it (like they were parts of
the same package).

@unnumberedsubsec How to Commit to a Submodule

There are two situations where you need to touch a submodule: either
you find a problem while working in the supermodule or you want to
use a newer version of the submodule.

In the latter case: the submodule has new useful commits and we want
to use them in the supermodule: just check-out the new upstream commit
in the submodule and then commit in the supermodule.

The former case is trickier: since the submodule is a read-only
checkout of another repository, normal users are not expected to
commit to a project from the place where it is just a submodule.
However, it sometimes happen when your multi-repository project is
still young, like @i{fmc-bus} as of 2012.

The directory of the submodule looks like a normal @t{git clone}, so
you can work in it in your usual way. However, the submodule is always
referencing a read-only upstream repository (because everybody should
be able to get the code), so you must add a new 
``@i{remote}'' git reference, like this:

@example
   morgana$ git remote -v
   origin  git://ohwr.org/fmc-projects/fmc-bus.git (fetch)
   origin  git://ohwr.org/fmc-projects/fmc-bus.git (push)
   morgana$ git remote add work $HOME/ohwr/fmc-bus
   morgana$ git remote -v
   origin  git://ohwr.org/fmc-projects/fmc-bus.git (fetch)
   origin  git://ohwr.org/fmc-projects/fmc-bus.git (push)
   work    /home/rubini/ohwr/fmc-bus (fetch)
   work    /home/rubini/ohwr/fmc-bus (push)
@end example

Now you can work normally and push to @i{work} (if you don't push, you
may loose the commit when working in the supermodule, which doesn't
consider the submodule a working directory).  If you end up using the
new commit in the supermodule, you must commit the supermodule too as
described above. Finally, you must ensure you push upstream the
submodule before you push the supermodule that uses the new commit.


@c ==========================================================================
@node Submodules and ``make install''
@section Git Submodules and ``make install''

In the context of @i{fmc-bus} drivers a mezzanine driver relies on the
core @t{fmc.ko} and the carrier driver.  The user who downloads the
mezzanine driver would like to ``@i{make && make install}'' and find
everything installed.

While this approach is easily achieved by arranging for @t{make
install} to install the submodules as well, this will introduce
problems for more advanced users, who are using different mezzanines
in the same host system. This is going to be pretty common, because
you can drive FMC mezzanines with @i{Etherbone}, so drivers in a
single host won't be limited to the few PCI or VME slots of your
desktop computer or crate.

The suggested behaviour for an FMC driver package is using
submodules for the drivers it depends on. However, it should
only install its own
kernel modules. If everything were installed automatically, we risked
overwriting already installed modules with a different version,
and we can't know if the user really wanted that -- those other
modules may be already installed and verified as part of another set of drivers.

The suggested @code{make install} rule, thus, only installs the
current package (the mezzanine or carrier driver the user checked
out) and prints this final line, explained by accompanying documentation.

@example
   WARNING: Consider "make prereq_install"
@end example

If a user is running a host with this mezzanine alone, then installing
the prerequisites is a safe move.  In this case
the warning message should not appear if you
@t{make install} again after you did @code{make prereq_install} once.
That's because technical users are expected to sometimes
edit and reinstall the specific driver, but not the ones it depends
on -- such drivers are considered stable infrastructure, like the kernel
or the compiler.

@c ==========================================================================
@node Suggestions for Mezzanine Drivers
@section Suggestions for Mezzanine Drivers

A mezzanine driver should include @i{fmc-bus} and the relevant carrier
drivers as submodules, in order to easily access the needed headers.
A mezzanine driver should compile the submodules as well, in order to find the
external symbols and not report scaring warnings at compile time.

While in a truly-portable mezzanine driver you won't need to access
headers of the carrier drivers, it's still good practice to carry them as
submodules, so the user can just @code{make prereq_install} and have
everything that's needed to run the hardware item.

The examples shown here are taken from @i{fine-delay}, the first
mezzanine driver that uses this multi-level approach. That specific driver also
uses ZIO as a submodule, but this has been stripped from the examples as
not relevant to @i{fmc-bus}.  The device driver itself lives
in the @i{kernel} subdirectory, because the package also features @i{tools}
and @i{lib}. This is expected to be common, so all code shown below uses
this convention; adapting to a driver without subdirectories is
expected to be easy.

First of all, the toplevel @code{Makefile} should have all the
standard targets, and run all of them in each subdirectory.  Moreover,
since most users don't run ``@code{git submodule init}'' or similar
commands, it should be done automatically the first time to avoid
errors that may be difficult to diagnose.

These are the relevant lines of the @code{Makefile}:

@smallexample
  .PHONY: gitmodules prereq prereq_install prereq_install_warn
  all clean modules install modules_install: gitmodules
          [...]

  gitmodules:
          @@test -d fmc-bus/doc || echo "Checking out submodules"
          @@test -d fmc-bus/doc || git submodule update --init

  # The user can override, using environment variables, all these three:
  FMC_BUS ?= fmc-bus
  SPEC_SW ?= spec-sw
  SUBMOD = $(FMC_BUS) $(SPEC_SW)

  prereq:
          for d in $(SUBMOD); do $(MAKE) -C $$d || exit 1; done

  prereq_install_warn:
          @@test -f .prereq_installed || \
                  echo -e "\n\n\tWARNING: Consider \"make prereq_install\"\n"

  prereq_install:
          for d in $(SUBMOD); do $(MAKE) -C $$d modules_install || exit 1; done
          touch .prereq_installed
@end smallexample

The snippet above implements the following:

@itemize @bullet

@item It checks out submodules if they are not already checked out.

@item It allows the user to override the submodules and use custom versions.
      by setting environment variables (@code{FMC_BUS} and @code{SPEC_SW}).

@item It implements the warning at installation time.

@item It has @code{prereq_install}, which stops the warning above.

@end itemize

The driver-specific makefile (here ``@code{kernel/Makefile}'')
must take care of finding the headers
at compile time and the external symbols at link time. This is
implemented using the standard @i{Kbuild} variables. Again, 
environment variable can be used to override the submodules with custom
clones of the repositories:

@smallexample
  LINUX ?= /lib/modules/$(shell uname -r)/build
  SPEC_SW ?= $(M)/../spec-sw
  FMC_BUS ?= $(M)/../fmc-bus

  KBUILD_EXTRA_SYMBOLS := \
          $(FMC_BUS)/kernel/Module.symvers


  ccflags-y = \
          -I$(SPEC_SW)/kernel \
          -I$(SPEC_SW)/kernel/include \
          -I$(FMC_BUS)/kernel/include \
          -I$M
@end smallexample

If the mezzanine driver is truly portable (which @i{fine-delay} is not,
as I write this), you won't need to point @code{ccflags-y}
to @code{$(SPEC_SW)}, which
is only compiled and installed for the user's convenience.

On the other hand, your mezzanine driver might also need to point
@code{KBUILD_EXTRA_SYMBOLS} to the carrier driver, whereas the example
above only uses symbols from @i{fmc-bus}.

@c ==========================================================================
@node Suggestions for Carrier Drivers
@section Suggestions for Carrier Drivers

A carrier driver should include @i{fmc-bus} as a submodule, in order
to easily access the relevant header files.  It should also compile
the submodule, to access the symbols exported by @code{fmc.ko} and
avoid unpleasant compilation warnings.

However, the repository of a carrier driver may be used as a submodule
of a mezzanine driver, which in turn already has @i{fmc-bus} as a
submodule (see @ref{Suggestions for Mezzanine Drivers}).  In general
you don't want @i{fmc-bus} to be replicated several times at different
directory levels if you clone a mezzanine driver.  If, by chance,
the user of the mezzanine driver changes something in the @i{fmc-bus},
nobody can easily say which one is the one being re-installed.

For this reason, the carrier driver should not checkout the submodule
if both the carrier itself and the @i{fmc-bus} package
are submodules of another driver.  Actually, this is also why
the @code{gitmodules:} rule suggested above for the mezzanine driver
doesn't use @code{--recursive}.

The following example is taken from @code{spec-sw}, the first carrier
driver we developed for this bus abstraction:

@smallexample
  FMC_DRV ?= $(shell ./check-fmc-bus)
  export FMC_DRV

  DIRS = $(FMC_DRV) kernel tools

  all clean modules install modules_install:
          for d in $(DIRS); do $(MAKE) -C $$d $@ || exit 1; done
@end smallexample

As you see, the variable @code{FMC_BUS} is conditionally assigned, so
the user can override it from the environment as usual. Moreover, the
default value is returned by a local shell script.

The script @code{check-fmc-bus} verifies
whether both this directory and @code{fmc-bus} are
submodules of some other git repository living in the parent directory.
If this is the case, @code{FMC_BUS} is
taken from the parent directory, otherwise it is taken from the local
subdirectory (the submodule).

@c ==========================================================================
@node Work in Progress
@section Work in Progress

Unfortunately, these procedures still miss some bits, that will be
dealt with as the system increases in complexity and number of users.

For example, the ``@i{gitmodules}'' target is missing from carrier
drivers, so a developer working directly on the carrier code should be
aware of submodules, and run @code{git submodule update --init} by
hand after a fresh checkout.  This is not yet performed by default
because I need to differentiate when the carrier driver is the main
checkout from when it is a submodule.

As the last bits are fixed I'll update this chapter, and I'll remove
this section when everything is verified by a larger user base.



@bye
@c  LocalWords:  gnudd titlepage iftex texinfo CERN documentlanguage settitle
@c  LocalWords:  documentencoding setfilename afourpaper paragraphindent SVEC
@c  LocalWords:  setchapternewpage finalout Etherbone EEPROM gateware busid
@c  LocalWords:  GPIO
